


def next_step_node(pre_states_node, pre_states_neig, weights_neig=[],
                   weights_temp=[]):
    '''The aim functionality of this function is to select and apply the
    desired method of evolution to the system.


    pre_states_node

    pre_states_neig

    weights_neig=[]

    weights_temp=[]


    TODO:    #print pre_states_node, pre_states_neig
    #print pre_states_node[-1], pre_states_neig[-1,:]
    weights_temp and functions is a functional information. Collapse these variables into one.
    '''
    method = 'conways'

    if method == 'conways':
        next_state_node = game_life_evolution_function(pre_states_node, pre_states_neig)
    else:
        next_state_node = game_life_evolution_function(pre_states_node, pre_states_neig)
    return next_state_node



########################## evolution

    ## 2. Net properties
    if type(net) == tuple:
        # Preparing inputs to the next_step_node function
        kwargs = from_net2dicts(net, pre_states)
    elif parallelize:
        # Information of the structure of the system ##### FAIL!!!!!
        info_str = get_node_list_structure_info(node_list, net, node_list,
                                                useweights)
        # Preparing inputs to the next_step_node function
        kwargs = from_net2dicts(info_str, pre_states)

    ## Compute next state in the parralel way
    if not parallelize:
        # For each node to be updated, search the new state
        for node in node_list:
            # Previous magnitudes needed
            node_index, neigh_index = get_node_structure_info(node, net,
                                                              node_list)
            # Computation of the next state
            jnod = node_list.index(node)
            kwargs = {'pre_states_node': pre_states[:, node_index],
                      'pre_states_neig': pre_states[:, neigh_index]}
            next_states[jnod] = next_step_node(**kwargs)

    elif parallelize == 'cpu':
        pool = multiprocessing.Pool()
        next_states = pool.map(next_step_node2, kwargs)

    elif parallelize == 'gpu':
        pass
    return next_states